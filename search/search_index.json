{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#the-future-of-digital-transformation","title":"The Future of Digital Transformation","text":"<p>Optimize efficiency, enhance security, and revolutionize business decision-making with the advanced Digital Twin Xautomata. Harness the power of our platform to integrate and contextualize every aspect of your business.</p>"},{"location":"agent/","title":"Agent installation manual","text":""},{"location":"agent/#installation-on-kubernetes","title":"Installation on Kubernetes","text":"<ul> <li>XAutomata UI configuration</li> <li>Create a new object, e.g., \"az-kubernetes.xautomata.com\"</li> <li>Create a probe of type \"agent\"</li> <li>Create a probe named \"kube-az-agent\" (include the configmap in the <code>data_profile</code>)</li> <li>Install <code>redpanda-console</code> via Helm chart and update the values to point to the environment's Kafka instance</li> <li>K8s Configuration</li> <li>Create the Kafka topic <code>log.probe.&lt;uuid_probe&gt;</code> to ingest logs from the probe \"kube-az-agent\" (using <code>redpanda-console</code>)</li> <li>Install the agent using the file <code>xautomata-agent-k8s.yaml</code> from the project sources, replacing the placeholder <code>&lt;probe_uuid&gt;</code> with the UUID of the probe \"kube-az-agent\"</li> </ul>"},{"location":"agent/#installation-on-local-machine","title":"Installation on Local Machine","text":"<ul> <li>Requirements</li> <li>Docker installed on machine</li> <li>Prerequisites</li> <li>Install ofelia container (https://hub.docker.com/r/mcuadros/ofelia)     <pre><code>docker pull mcuadros/ofelia\n</code></pre>     ...TBC...</li> </ul>"},{"location":"file_esempio/","title":"Titolo","text":""},{"location":"file_esempio/#sotto-titolo","title":"sotto titolo","text":""},{"location":"file_esempio/#sotto-sotto-titolo","title":"sotto sotto titolo","text":"<p>testo</p> <p>example</p> <p>example</p> <p>note per un quote</p> <pre><code>code\n</code></pre>"},{"location":"info/","title":"Generic documentation of the XA system","text":"<p>The structure of XAUTOMATA is complex and combines elements of a tree hierarchy with lists from a graph, but if we focus on the interaction with the elements of a client's asset, the complexity is somewhat reduced.</p> <p>We can envision having a client's asset and a series of services that point to that asset, enriching the information present or adding functionality.</p>"},{"location":"info/#the-asset","title":"The Asset","text":"<p>As an asset, we define everything that constitutes the client's physical perimeter. The asset is hierarchically defined by the following components (in descending hierarchical order): - Customer - Site - Group - Object - Metric_type - Metric - Service</p> <p>Each of these levels contains information; the customer defines the client, the sites define the client's branches, etc. Each level is connected with a one-to-many relationship to the level below, meaning a site has groups within it, but a group cannot exist in multiple sites. </p> <p>There is an exception for groups; for the most part, they maintain a one-to-many relationship with metric types, but an object can belong to multiple groups. Thus, we can say that there is a many-to-many relationship between groups and objects.</p> <p>Each element can be identified by a series of primary keys that also include the UUID of its upper level. This, of course, is not true for objects due to the many-to-many nature with groups.</p> <p>The services that close the hierarchy represent a second exception: they have a hierarchical importance similar to metrics, can be linked to metrics in a many-to-many relationship, but may also exist completely independent of the asset. Services provide additional information derived from customer values or other data and are not necessarily tied to the asset. If they are linked to the asset, it is through the metrics, in which case there is a reference to all the metrics that contributed to forming the service.</p> <p>The structure from the customer to the service represents the asset and is referred to as the tree.</p> <p>To navigate the tree, there are APIs that allow you to obtain the linking information of one layer with the others. For example, if I know a metric and want to find out which object it belongs to, the metric data itself contains the uuid of the metric_type that encompasses it. With that uuid, I can retrieve the details of the metric_type, which includes the uuid of the object it contains. With that uuid, I can then request the details of the object I was interested in.</p> <p>The same is true in the opposite direction; if I identify an object, I can find out all the metric_types that comprise it, and by selecting one, I can request all the metrics that belong to it.</p> <p>This method of navigating the tree has some variations when trying to traverse layers with many-to-many relationships. To find out which groups contain an object and vice versa, there are specific APIs that, given one of the two layers, will return the other. This also applies to services, which have the same many-to-many nature.</p> <p>There are shortcuts for navigating the tree, and these shortcuts take the form of the tree_hierarchy API set. This API is designed to retrieve an element in the tree along with all its links to the upper layers.</p>"},{"location":"info/#time-series","title":"Time Series","text":"<p>The asset represents the objects that produce data, but the data itself is collected in a different location, specifically in time series tables. </p> <p>These series are divided into two types: state series and value series.</p> <p>State series are a succession of information collected in dictionaries; they can contain any type of information and carry a gravity index. Value series are sequences of numbers, ideal for collecting numerical data such as temperature, speed, etc.</p> <p>Metrics are the layer where these series are stored. Each metric is directly linked to one and only one time series, whether it is a state series or a value series.</p> <p>Services can also be linked to time series, and unlike metrics, they can simultaneously point to both value series and state series.</p>"},{"location":"info/#additional-information","title":"Additional Information","text":"<p>Relationships do not end with the asset; there is a myriad of additional information that can be explored, such as users, dashboards, and so on. The way to navigate these connections is the same as navigating the tree.</p> <p>The complete connection between all elements accessible via API is presented in the diagram below.</p> <p></p>"},{"location":"frontend/","title":"XA Frontend - User Manual","text":""},{"location":"frontend/login/","title":"Login","text":""},{"location":"frontend/accounting/cost_views/","title":"Cost Views","text":""},{"location":"frontend/administration/","title":"Administration - Overview","text":""},{"location":"frontend/administration/messages/","title":"Messages","text":""},{"location":"frontend/administration/notification_provider_types/","title":"Notification Provider Types","text":""},{"location":"frontend/administration/notification_providers/","title":"Notification Providers","text":""},{"location":"frontend/administration/opening_reasons/","title":"Opening Reasons","text":""},{"location":"frontend/administration/probe_types/","title":"Probe Types","text":""},{"location":"frontend/administration/probes/","title":"Probes","text":""},{"location":"frontend/administration/reasons_for_closures/","title":"Reason For Closure","text":""},{"location":"frontend/administration/users/","title":"Users","text":""},{"location":"frontend/administration/virtual_domains/","title":"Virtual Domains","text":""},{"location":"frontend/authentication/","title":"Authentication Overview","text":"<p>The Authentication section of Xautomata\u2019s documentation provides a comprehensive look at user authentication processes within the platform. Authentication involves multiple workflows to ensure secure access, manage user sessions, and handle related actions, such as resetting passwords and accepting terms and conditions. Each process in this section is documented with its purpose, flow, and code references.</p>"},{"location":"frontend/authentication/#authentication-processes","title":"Authentication Processes","text":"<p>The following processes are included in the Authentication section:</p> <ul> <li>Login: Covers the user login process, detailing the flow from credential entry to token management and session handling.</li> <li>Logout: Explains how to securely end a user session, including token invalidation and session cleanup.</li> <li>First Login: Describes the onboarding process for new users during their initial login, including account setup and customer assignment.</li> <li>Reset Password: Provides the workflow for password recovery and reset, detailing user interactions and API calls.</li> <li>Terms and Conditions: Outlines how users accept or reject terms and conditions, with API references for status updates.</li> </ul>"},{"location":"frontend/authentication/#technical-structure","title":"Technical Structure","text":""},{"location":"frontend/authentication/#key-components","title":"Key Components","text":"<p>Authentication processes in Xautomata rely on several key components and files: - Views: The primary user interfaces for each authentication process are defined in individual Vue components under <code>src/authentication/views</code>. These include <code>LoginView.vue</code>, <code>LogoutView.vue</code>, <code>ResetPasswordView.vue</code>, and others. - Stores: User authentication state is managed within the <code>auth</code> and <code>user</code> stores located in <code>src/authentication/stores</code>. These stores handle session tokens, user data, and state persistence. - API Services: All API calls related to authentication are implemented in <code>Api.ts</code> under <code>src/services</code>, which acts as an interface for each process, managing requests to the server.</p>"},{"location":"frontend/authentication/#core-concepts","title":"Core Concepts","text":"<p>Each authentication flow leverages a set of core concepts to streamline and secure user interactions:</p> <ul> <li>Token Management: Handles user access tokens, including refreshing and invalidating tokens when necessary.</li> <li>Session Persistence: The application uses stores to persist session data, ensuring a consistent user experience across sessions.</li> <li>Error Handling: Authentication processes include specific error handling to manage login failures, invalid tokens, and other issues.</li> </ul>"},{"location":"frontend/authentication/#navigating-the-authentication-documentation","title":"Navigating the Authentication Documentation","text":"<p>Each page in this section dives into the specifics of the authentication process, with examples and links to the corresponding code files to guide implementation.</p> <p>For more details, explore each process page linked above.</p>"},{"location":"frontend/authentication/first_login/","title":"First Login","text":"<p>This page provides an overview of the First Login process in the Xautomata platform. During the first login, new users are guided through additional steps, such as associating with a customer account, accepting terms and conditions, and possibly creating a new customer if they are administrators.</p>"},{"location":"frontend/authentication/first_login/#overview","title":"Overview","text":"<p>The first login involves the following key steps: 1. User Login: The user provides credentials, triggering authentication. 2. Customer Association: New users are prompted to associate with an existing customer or create a new one. 3. Terms and Conditions: Users must accept the latest terms and conditions. 4. Dashboard Redirection: Once setup is complete, users are redirected to their dashboard.</p>"},{"location":"frontend/authentication/first_login/#process-details","title":"Process Details","text":""},{"location":"frontend/authentication/first_login/#1-user-login","title":"1. User Login","text":"<p>The user starts by providing their credentials. The login information is handled by <code>authStore</code> and the <code>authenticate</code> function.</p> <pre><code>async function loginByCredentials(): Promise&lt;void&gt; {\n  isLoading.value = true\n  authError.value = null\n\n  try {\n    await authStore.authenticate(\n      username.value,\n      password.value,\n      isRemember.value\n    )\n    await userStore.initStore()\n    router.push({ name: 'CustomersHomePage' })\n  } catch (err) {\n    handleLoginError(err)\n  } finally {\n    isLoading.value = false\n  }\n}\n</code></pre>"},{"location":"frontend/authentication/first_login/#2-customer-association","title":"2. Customer Association","text":"<p>After logging in, users without a customer association are prompted to either join an existing customer or create a new customer.</p> <pre><code>async function createNewCustomer(): Promise&lt;void&gt; {\n  isLoading.value = true\n  try {\n    await Api.registerNewCustomer(customer.value)\n    await afterCreatingCustomer()\n    goToDashboards()\n  } catch (err) {\n    console.error(err)\n  } finally {\n    isLoading.value = false\n  }\n}\n</code></pre>"},{"location":"frontend/authentication/first_login/#3-terms-and-conditions","title":"3. Terms and Conditions","text":"<p>During the first login, users may be required to accept the platform\u2019s terms and conditions. This is handled in the user store, prompting the user to accept the latest terms before proceeding.</p> <pre><code>// Code snippet from user store handling terms and conditions acceptance\n\nasync function loadCurrentUser(): Promise&lt;void&gt; {\n  const currentUser = await Api.loadCurrentUser()\n\n  if (currentUser.profile === 'sign_tc') {\n    const onAccept = async (version: number) =&gt; {\n      const signOptions = { isAccepted: true, version }\n      await Api.signTermsAndConditions(signOptions)\n    }\n    uiStore.openDialog({\n      component: shallowRef(TermsAndConditionsDialog),\n      props: { isRefuseEnabled: true, onAccept }\n    })\n  }\n\n  user.value = currentUser\n}\n</code></pre>"},{"location":"frontend/authentication/first_login/#4-dashboard-redirection","title":"4. Dashboard Redirection","text":"<p>Once the first login process is complete, users are redirected to the main dashboard.</p> <pre><code>function goToDashboards(): void {\n  setTimeout(() =&gt; {\n    router.push({ name: 'CustomersHomePage' })\n  }, 3000)\n}\n</code></pre> <p>At this point, the first login process concludes with a redirect to the user\u2019s main dashboard. </p> <p>With these steps complete, the first login process ensures that new users are set up with customer association and have accepted terms and conditions before accessing the platform's main features.</p>"},{"location":"frontend/authentication/login/","title":"Login Process","text":"<p>The Login process in Xautomata allows users to authenticate with the platform securely. This document explains the workflow, key components, and associated API calls involved in the login process, alongside error handling and session management.</p>"},{"location":"frontend/authentication/login/#overview","title":"Overview","text":"<p>The login process involves: 1. User credential submission (username and password). 2. API authentication request to validate credentials. 3. Token management, including storage of access and refresh tokens for session persistence.</p>"},{"location":"frontend/authentication/login/#workflow","title":"Workflow","text":"<ol> <li>Credential Input: </li> <li> <p>Users enter their username and password in the <code>LoginView.vue</code> component. This data is managed by Vue\u2019s reactivity system and is validated before submission.</p> </li> <li> <p>API Authentication Call: </p> </li> <li>The login request is handled by the <code>authenticate</code> method in <code>authStore</code> (defined in <code>src/authentication/stores/auth.ts</code>). It constructs an authentication payload using the credentials and an option for session persistence.</li> <li> <p>API call is made via <code>Api.authenticate</code> function (defined in <code>Api.ts</code> within <code>src/services</code>). This function sends a <code>POST</code> request to the server's OAuth endpoint to verify credentials.</p> </li> <li> <p>Token and Session Handling:</p> </li> <li>If successful, the response includes an <code>access_token</code> and additional session data (e.g., <code>expires_in</code>, <code>token_type</code>), which are saved in the <code>authStore</code>.</li> <li>The <code>userStore</code> initializes user data post-authentication by calling <code>initStore</code>, which fetches user-specific information like profile data and notifications.</li> </ol> <p>Read more</p> <ol> <li>Redirect on Success:</li> <li>After a successful login, the application redirects the user to the main dashboard (<code>CustomersHomePage</code>), defined within the Vue Router configuration in <code>routes.ts</code>.</li> </ol>"},{"location":"frontend/authentication/login/#key-components-and-files","title":"Key Components and Files","text":"<ul> <li>LoginView.vue: The UI component for the login page, which includes fields for entering credentials and buttons for submitting the form.</li> <li>authStore (auth.ts): Manages the login state, including token storage and API interaction for authentication.</li> <li>Api.ts: Defines the <code>authenticate</code> function, which communicates with the server\u2019s OAuth endpoint to validate credentials.</li> <li>routes.ts: Configures route redirection after successful login.</li> </ul>"},{"location":"frontend/authentication/login/#api-details","title":"API Details","text":"<ul> <li>Endpoint: <code>/oauth2/login_access_token</code></li> <li>Method: <code>POST</code></li> <li>Request Payload:</li> </ul> <pre><code>{\n  \"username\": \"&lt;user_username&gt;\",\n  \"password\": \"&lt;user_password&gt;\",\n  \"value_refresh_token\": \"&lt;session|remember_me&gt;\"\n}\n</code></pre> <ul> <li>Response:</li> <li><code>access_token</code>: JWT used for authenticated requests.</li> <li><code>expires_in</code>: Duration for which the token is valid.</li> <li><code>token_type</code>: Type of token (typically <code>Bearer</code>).</li> </ul>"},{"location":"frontend/authentication/login/#error-handling","title":"Error Handling","text":"<ul> <li>Invalid Credentials: If the credentials are incorrect, an error message is displayed in <code>LoginView.vue</code>, prompting the user to re-enter their details.</li> <li>Network Issues: Any connectivity issues are logged, and a user-friendly message is displayed.</li> <li>Session Expiration: If the session expires, users are prompted to re-authenticate.</li> </ul>"},{"location":"frontend/authentication/login/#code-references","title":"Code References","text":"<ul> <li><code>src/authentication/views/LoginView.vue</code>: User interface and event handling for login.</li> <li><code>src/authentication/stores/auth.ts</code>: Token management and API calls for login.</li> <li><code>src/services/Api.ts</code>: Defines the API call to the authentication endpoint.</li> </ul>"},{"location":"frontend/authentication/login/#example","title":"Example","text":"<p>An example login function using <code>authStore</code>:</p> <pre><code>import { useAuthStore } from '@/authentication/stores/auth'\n\nconst authStore = useAuthStore()\n\nasync function login() {\n  try {\n    await authStore.authenticate(username, password, isRemember)\n    // Redirect to homepage on success\n    router.push({ name: 'CustomersHomePage' })\n  } catch (error) {\n    console.error('Login failed:', error)\n    // Display error message to the user\n  }\n}\n</code></pre>"},{"location":"frontend/authentication/login_sso/","title":"Login with SSO","text":""},{"location":"frontend/authentication/logout/","title":"Logout Process","text":"<p>The Logout process in Xautomata is designed to securely end a user\u2019s session, ensuring that all active tokens are invalidated and the user is logged out of the application. This document outlines the logout workflow, key components, and session cleanup steps.</p>"},{"location":"frontend/authentication/logout/#overview","title":"Overview","text":"<p>The logout process includes: 1. Invalidating the access token on the server. 2. Clearing stored session data and tokens. 3. Redirecting the user to the login page.</p>"},{"location":"frontend/authentication/logout/#workflow","title":"Workflow","text":"<ol> <li>Trigger Logout Action:</li> <li> <p>The logout process is triggered by calling the <code>logout</code> function in the <code>authStore</code> (defined in <code>src/authentication/stores/auth.ts</code>).</p> </li> <li> <p>Token Invalidations:</p> </li> <li>If the user has an active push notification token, it is invalidated first by calling <code>Api.invalidatePushToken</code>.</li> <li> <p>The primary session token is then invalidated via <code>Api.invalidateToken</code>, which clears the user\u2019s server session and prevents unauthorized access using the token.</p> </li> <li> <p>Session Data Reset:</p> </li> <li> <p>After invalidating tokens, <code>authStore</code> calls <code>resetStore</code> to clear all session-related data, including user information and tokens.</p> </li> <li> <p>Redirection:</p> </li> <li>Upon successful logout, the application redirects the user to the login page.</li> </ol>"},{"location":"frontend/authentication/logout/#key-components-and-files","title":"Key Components and Files","text":"<ul> <li>authStore (auth.ts): Manages the logout function and session state clearing.</li> <li>Api.ts: Defines the <code>invalidateToken</code> and <code>invalidatePushToken</code> functions, which handle server requests to clear active tokens.</li> <li>LoginView.vue: The user is redirected to this component after logout.</li> </ul>"},{"location":"frontend/authentication/logout/#api-details","title":"API Details","text":"<ul> <li>Endpoint: <code>/login/refresh/invalidate</code></li> <li>Method: <code>POST</code></li> <li>Purpose: Clears the current user session on the server and invalidates the access token.</li> </ul>"},{"location":"frontend/authentication/logout/#example-code","title":"Example Code","text":"<p>Here is an example of the logout function defined in <code>authStore</code>:</p> <pre><code>import { useAuthStore } from '@/authentication/stores/auth'\nimport { useApi } from '@/common/composables/Services'\n\nconst authStore = useAuthStore()\nconst { Api } = useApi()\n\nasync function logout() {\n  try {\n    if (authStore.token.value.access_token) {\n      // Invalidate push token if present\n      if (appStore.pushToken) {\n        await Api.invalidatePushToken(appStore.pushToken)\n      }\n      // Invalidate main session token\n      await Api.invalidateToken()\n    }\n  } catch (error) {\n    console.error('Logout failed:', error)\n  } finally {\n    // Reset session data\n    authStore.resetStore()\n  }\n}\n</code></pre>"},{"location":"frontend/authentication/logout/#error-handling","title":"Error Handling","text":"<ul> <li>Token Invalidation Failure: If token invalidation fails, an error is logged but the session data is still cleared to ensure no sensitive information is retained.</li> <li>Network Issues: In case of network issues, the user\u2019s local session is cleared, though the server-side token may remain active until it expires.</li> </ul>"},{"location":"frontend/authentication/logout/#code-references","title":"Code References","text":"<ul> <li><code>src/authentication/stores/auth.ts</code>: Contains the <code>logout</code> and <code>resetStore</code> functions.</li> <li><code>src/services/Api.ts</code>: Defines functions for invalidating tokens.</li> </ul> <p>This document covers the logout process, clarifying the steps to ensure session security when a user logs out.</p>"},{"location":"frontend/authentication/reset_password/","title":"Reset Password","text":"<p>This page details the Reset Password process in Xautomata. This process allows users to reset their password if they have forgotten it or need to update it. The reset password flow includes requesting a reset email and validating the reset link before entering a new password.</p>"},{"location":"frontend/authentication/reset_password/#overview","title":"Overview","text":"<p>The reset password process involves these main steps: 1. Request Reset: The user requests a password reset, typically by entering their username or email. 2. Verification: The user receives a verification link and follows it to confirm their identity. 3. Password Update: After verification, the user can set a new password to regain access.</p>"},{"location":"frontend/authentication/reset_password/#process-details","title":"Process Details","text":""},{"location":"frontend/authentication/reset_password/#1-request-reset","title":"1. Request Reset","text":"<p>The reset process begins when the user provides their username or email to request a password reset. This request triggers a call to the API to send an email with a verification code.</p> Click to view `ResetPasswordView.vue` code snippet for reset request <pre><code>async function requestResetPassword(): Promise&lt;void&gt; {\n  isLoading.value = true\n\n  try {\n    await Api.requestResetPassword(profile.value.userName)\n    goToLogin()\n  } catch (err) {\n    console.error(err)\n  } finally {\n    isLoading.value = false\n  }\n}\n</code></pre>"},{"location":"frontend/authentication/reset_password/#2-verification","title":"2. Verification","text":"<p>After requesting a password reset, the user receives an email with a verification code. The code is passed as a query parameter when the user follows the email link. This code is used to verify the user's identity.</p> Click to view code snippet for verification handling <pre><code>const code = route.query.verification_code as string\n\nasync function resetPassword(): Promise&lt;void&gt; {\n  isLoading.value = true\n\n  try {\n    await Api.resetPassword({\n      verification_code: code,\n      new_password: changePassword.value.password\n    })\n    goToLogin()\n  } catch (err) {\n    console.error(err)\n  } finally {\n    isLoading.value = false\n  }\n}\n</code></pre>"},{"location":"frontend/authentication/reset_password/#3-password-update","title":"3. Password Update","text":"<p>Once verification is successful, the user can enter and confirm a new password. This final step completes the reset process and allows the user to log in with their updated password.</p> Click to view password update snippet <pre><code>const changePasswordFields = ref&lt;Array&lt;FieldOptions&gt;&gt;([  {    key: 'password',    type: FieldType.Password,    placeholder: 'Password',    validations: [      required,      lowerRequired,      upperRequired,      numberRequired,      specialSymbolRequired,      whiteSpacesNotAllowed,      minLength(8)    ]\n  },\n  {\n    key: 'passwordConfirm',\n    type: FieldType.Password,\n    placeholder: 'Confirm password',\n    validations: [sameAs(passwordComputed)]\n  }\n])\n</code></pre> <p>This concludes the reset password process. By following these steps, users can securely reset their password and regain access to the platform.</p>"},{"location":"frontend/authentication/terms_conditions/","title":"Terms and Conditions","text":"<p>This page outlines the Terms and Conditions acceptance process in Xautomata. During the first login, users may be prompted to review and accept the platform's terms and conditions. This acceptance is mandatory for account activation.</p>"},{"location":"frontend/authentication/terms_conditions/#overview","title":"Overview","text":"<p>The Terms and Conditions process includes the following steps: 1. Prompt Display: Upon login, if the terms have not been accepted, the user is prompted to review them. 2. Acceptance Handling: Users can accept or decline the terms. 3. Account Activation: Once accepted, the user's account is fully activated.</p>"},{"location":"frontend/authentication/terms_conditions/#process-details","title":"Process Details","text":""},{"location":"frontend/authentication/terms_conditions/#1-prompt-display","title":"1. Prompt Display","text":"<p>When a new user logs in, the system checks if the latest terms have been accepted. If not, a dialog prompt with the terms is displayed, requiring user action before proceeding.</p> Click to view `loadCurrentUser` method for terms acceptance check <pre><code>// Code snippet from user store checking terms acceptance\n\nasync function loadCurrentUser(): Promise&lt;void&gt; {\n  const currentUser = await Api.loadCurrentUser()\n\n  if (currentUser.profile === 'sign_tc') {\n    const onAccept = async (version: number) =&gt; {\n      const signOptions = { isAccepted: true, version }\n      await Api.signTermsAndConditions(signOptions)\n    }\n    uiStore.openDialog({\n      component: shallowRef(TermsAndConditionsDialog),\n      props: { isRefuseEnabled: true, onAccept }\n    })\n  }\n\n  user.value = currentUser\n}\n</code></pre>"},{"location":"frontend/authentication/terms_conditions/#2-acceptance-handling","title":"2. Acceptance Handling","text":"<p>The dialog allows users to either accept or decline the terms. The <code>onAccept</code> function processes acceptance, storing the decision.</p> Click to view `signTermsAndConditions` method <pre><code>// Code snippet from Api.ts handling terms acceptance submission\n\nasync function signTermsAndConditions(\n  options: SignTermsAndConditionsOptions\n): Promise&lt;void&gt; {\n  const data = {\n    tc_version: options.version,\n    accepted: options.isAccepted\n  }\n\n  await client.user_approved_or_declined_tc_login_current_user_terms_and_conditions_post(\n    {},\n    data\n  )\n}\n</code></pre>"},{"location":"frontend/authentication/terms_conditions/#3-account-activation","title":"3. Account Activation","text":"<p>Once terms are accepted, the account is activated, allowing users to access the platform's main features.</p> <p>This completes the Terms and Conditions process, ensuring all users have acknowledged the platform\u2019s legal guidelines before accessing the system.</p>"},{"location":"frontend/cloud_costs/","title":"Cloud Cost Registration - Overview","text":""},{"location":"frontend/cloud_costs/aws/","title":"AWS","text":""},{"location":"frontend/cloud_costs/azure/","title":"Azure","text":""},{"location":"frontend/cloud_costs/azure_csp/","title":"Azure CSP","text":""},{"location":"frontend/cloud_costs/google/","title":"Google","text":""},{"location":"frontend/customers/","title":"Customers - Overview","text":""},{"location":"frontend/customers/contacts/","title":"Contacts","text":""},{"location":"frontend/customers/customers/","title":"Customers","text":""},{"location":"frontend/customers/sites/","title":"Sites","text":""},{"location":"frontend/objects/","title":"Objects - Overview","text":""},{"location":"frontend/objects/groups/","title":"Groups","text":""},{"location":"frontend/objects/metric_types/","title":"Metric Types","text":""},{"location":"frontend/objects/metrics/","title":"Metrics","text":""},{"location":"frontend/objects/objects/","title":"Objects","text":""},{"location":"frontend/objects/services/","title":"Services","text":""},{"location":"frontend/super_admin/","title":"Super Admin - Overview","text":""},{"location":"frontend/super_admin/acl_overrides/","title":"ACL Overrides","text":""},{"location":"frontend/super_admin/dashboards/","title":"Dashboards","text":""},{"location":"frontend/super_admin/widget_groups/","title":"Widget Groups","text":""},{"location":"frontend/super_admin/widgets/","title":"Widgets","text":""},{"location":"frontend/tracking/","title":"Tracking - Overview","text":""},{"location":"frontend/tracking/calendars/","title":"Calendars","text":""},{"location":"frontend/tracking/dispatchers/","title":"Dispatchers","text":""},{"location":"frontend/tracking/downtimes/","title":"Downtimes","text":""}]}